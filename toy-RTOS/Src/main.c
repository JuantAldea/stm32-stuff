/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <kernel.h>
#include <stdio.h>
#include <stdint.h>
#include <stm32f407xx.h>
#include "config.h"
#include "timebase.h"
#include "led.h"
#include "uart.h"
#include "kernel.h"
#include "STM32F407VET6_RTOS_BSP.h"

uint32_t task0_prof, task1_prof, task2_prof, task3_prof;
int32_t sem1, sem2;
uint32_t sum = 0;
/*
 volatile int in_counter = 0;
 volatile int out_counter = 3;
 volatile int32_t barrier_semaphore;

 void barrier(volatile int32_t *semaphore, int p)
 {
 osSemaphoreTakeYield(semaphore);

 if (!in_counter){

 }
 while(out_counter != p) {
 osSemaphoreGive(semaphore);
 osSemaphoreTakeYield(semaphore);
 }

 in_counter++;
 if (in_counter == p){
 in_counter = 0;
 }

 while(in_counter != p){
 osSemaphoreGive(semaphore);
 osSemaphoreTakeYield(semaphore);
 }

 out_counter++;
 osSemaphoreGive(semaphore);
 }

 void barrier_Init(volatile int32_t *semaphore, int n){
 counter = n;
 osSemaphoreInit(semaphore, 1);
 }
 */
uint32_t btn1, btn2, btn3;
void task0()
{
    task0_prof = 0;
    while (1) {
        //osSemaphoreTakeYield(&sem1);
        task0_prof++;
        BSP_led1_toggle();
        btn1 = BPS_button_WK_UP_read();
        btn2 = BPS_button_K0_read();
        btn3 = BPS_button_K1_read();
        BSP_delay_ms(1000);

        //barrier(&barrier_semaphore);
        //sum++;
        //osSemaphoreGive(&sem1);
    }
}

void task1()
{
    task1_prof = 0;
    while (1) {
        //osSemaphoreTakeYield(&sem1);
        task1_prof++;
        for (int i = 0; i < 100000; i++);
        //barrier(&barrier_semaphore);
        //sum++;
        //osSemaphoreGive(&sem1);
    }
}

void task2()
{
    task2_prof = 0;
    while (1) {
        //osSemaphoreTakeYield(&sem1);
        task2_prof++;
        //barrier(&barrier_semaphore);
        for (int i = 0; i < 1000000; i++);
        //sum++;
        //osSemaphoreGive(&sem1);
    }
}

void taskLed0()
{
    task3_prof++;
    led_toggle(LED_0);
}

void taskLed1()
{
    led_toggle(LED_1);
}

struct __FILE {
    int handle;
};

FILE __stdin = { (unsigned char *) 0 };
FILE __stdout = { (unsigned char *) 1 };
FILE __stderr = { (unsigned char *) 2 };

uint32_t sensor_value;
int main(void)
{
    sum = 0;
    //osSemaphoreInit(&sem1, 1);
    //barrier_Init(&barrier_semaphore, 3);
    uart1_init();
    //timebase_init();
    //leds_init();
    BSP_led_init();
    BSP_adc1_init();
    BSP_buttons_init();
    BPS_probes_init();

    int n;
    char s[10];
    printf("enter a number: ");
    scanf(" %d", &n);
    printf("Number was: %d\r\n", n);
    printf("enter a string: ");
    gets(s);
    printf("%s\r\n", s);
    while (1) {}
    ;
    setvbuf(stdin, NULL, _IONBF, 0);
    while (1) {
        btn1 = BPS_button_WK_UP_read();
        btn2 = BPS_button_K0_read();
        btn3 = BPS_button_K1_read();
        BPS_probe_toggle(PROBE0);
        BPS_probe_toggle(PROBE1);
        BPS_probe_toggle(PROBE2);
        BPS_probe_toggle(PROBE3);
        BPS_probe_toggle(PROBE4);
        BSP_delay_ms(1000);
    }
    //timer2_1hz_init();

    printf("FINISHED\r\n");
    osKernelInit();
    osKernelAddThreads(task0, task1, task2);

    //osAddPeriodicTask(taskLed0, 1);
    //osAddPeriodicTask(taskLed1, 10);
    //osPeriodicTasks_Init(10, 6);
    osKernelLaunch(10);
}
